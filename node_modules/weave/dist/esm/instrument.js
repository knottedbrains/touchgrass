"use strict";
// @ts-ignore-file This file is compiled as ESM via tsconfig.instrument.json
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const satisfies = require('semifies');
const { register } = require('node:module');
const { pathToFileURL } = require('node:url');
const import_in_the_middle_1 = require("import-in-the-middle");
require('../integrations/hooks');
const instrumentations_1 = require("../integrations/instrumentations");
const npmModuleUtils_1 = require("../utils/npmModuleUtils");
const semifies_1 = __importDefault(require("semifies"));
const { registerOptions, waitForAllMessagesAcknowledged } = (0, import_in_the_middle_1.createAddHookMessageChannel)();
register('import-in-the-middle/hook.mjs', pathToFileURL(__filename), registerOptions);
(async () => {
    await waitForAllMessagesAcknowledged();
    if (satisfies(process.versions.node, '>=14.13.1')) {
        const modules = (0, instrumentations_1.getESMInstrumentedModules)();
        for (const module of modules) {
            new import_in_the_middle_1.Hook([module], (exported, name, baseDir) => {
                const cachedModule = global[instrumentations_1.symESMCache].get(module);
                if (cachedModule) {
                    return cachedModule.patchedExports;
                }
                const instrumentations = global[instrumentations_1.symESMInstrumentations];
                const instrumentationsForModule = instrumentations.get(module);
                let instrumentation = null;
                let packageJson;
                try {
                    packageJson = (0, npmModuleUtils_1.requirePackageJson)(baseDir, []);
                }
                catch (e) {
                    console.warn(`Cannot find package.json for ${name}, ${baseDir}. Not patching`);
                    return exported;
                }
                if (instrumentationsForModule) {
                    for (const instrumentationCandidate of instrumentationsForModule) {
                        if ((0, semifies_1.default)(packageJson.version, instrumentationCandidate.version)) {
                            instrumentation = instrumentationCandidate;
                            break;
                        }
                    }
                    if (!instrumentation) {
                        return exported;
                    }
                    const patchedExports = instrumentation.hook(exported, name, baseDir);
                    global[instrumentations_1.symESMCache].set(module, {
                        originalExports: exported,
                        patchedExports,
                    });
                    return patchedExports;
                }
            });
        }
    }
    else {
        console.warn('ESM is not fully supported by this version of Node.js, ' +
            'so Weave will not intercept ESM loading.');
    }
})();
//# sourceMappingURL=instrument.js.map