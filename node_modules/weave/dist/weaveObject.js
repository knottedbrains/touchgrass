"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WeaveObject = exports.ObjectRef = void 0;
exports.getClassChain = getClassChain;
const clientApi_1 = require("./clientApi");
const op_1 = require("./op");
const urls_1 = require("./urls");
/**
 * Represents a reference to a saved Weave object.
 *
 * Generally, end users will not need to interact with this class directly.
 *
 * An ObjectRef contains the project ID, object ID, and digest that uniquely identify
 * a saved object in Weave's storage system.
 *
 * @example
 * const ref = new ObjectRef('my-project', 'abc123', 'def456');
 * const uri = ref.uri(); // weave:///my-project/object/abc123:def456
 */
class ObjectRef {
    constructor(projectId, objectId, digest) {
        this.projectId = projectId;
        this.objectId = objectId;
        this.digest = digest;
    }
    // TODO: Add extra
    uri() {
        return `weave:///${this.projectId}/object/${this.objectId}:${this.digest}`;
    }
    ui_url() {
        const domain = (0, urls_1.getGlobalDomain)();
        return `https://${domain}/${this.projectId}/weave/objects/${this.objectId}/versions/${this.digest}`;
    }
    async get() {
        const client = (0, clientApi_1.requireGlobalClient)();
        return await client.get(this);
    }
}
exports.ObjectRef = ObjectRef;
class WeaveObject {
    constructor(_baseParameters) {
        this._baseParameters = _baseParameters;
    }
    className() {
        return Object.getPrototypeOf(this).constructor.name;
    }
    saveAttrs() {
        var _a, _b;
        const attrs = {
            name: (_a = this._baseParameters) === null || _a === void 0 ? void 0 : _a.name,
            description: (_b = this._baseParameters) === null || _b === void 0 ? void 0 : _b.description,
        };
        for (const key of Object.keys(this)) {
            if (!key.startsWith('_')) {
                // @ts-ignore
                const value = this[key];
                if ((0, op_1.isOp)(value) || typeof value !== 'function') {
                    attrs[key] = value;
                }
            }
        }
        return attrs;
    }
    get name() {
        var _a;
        return (_a = this._baseParameters.name) !== null && _a !== void 0 ? _a : this.constructor.name;
    }
    get description() {
        return this._baseParameters.description;
    }
}
exports.WeaveObject = WeaveObject;
function getClassChain(instance) {
    const bases = [];
    let currentProto = Object.getPrototypeOf(instance);
    while (currentProto && currentProto.constructor.name !== 'Object') {
        const className = currentProto.constructor.name === 'WeaveObject'
            ? 'Object'
            : currentProto.constructor.name;
        bases.push(className);
        currentProto = Object.getPrototypeOf(currentProto);
    }
    // Frontend does this overly specific check for datasets, so push BaseModel to ensure we pass for now.
    //   data._type === 'Dataset' &&
    //   data._class_name === 'Dataset' &&
    //   _.isEqual(data._bases, ['Object', 'BaseModel'])
    bases.push('BaseModel');
    return bases;
}
//# sourceMappingURL=weaveObject.js.map