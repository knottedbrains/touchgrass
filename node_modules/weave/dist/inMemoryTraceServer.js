"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InMemoryTraceServer = void 0;
const uuidv7_1 = require("uuidv7");
class InMemoryTraceServer {
    constructor() {
        this._calls = [];
        this._objs = [];
        this._files = [];
        this._lastCallCount = 0;
        this._lastChangeTime = Date.now();
        this.call = {
            callStartBatchCallUpsertBatchPost: async (batchReq) => {
                for (const item of batchReq.batch) {
                    if (item.mode === 'start') {
                        this._calls.push(item.req.start);
                        this._updateChangeTime();
                    }
                    else if (item.mode === 'end') {
                        const call = this._calls.find(c => c.id === item.req.end.id);
                        if (call) {
                            Object.assign(call, item.req.end);
                            this._updateChangeTime();
                        }
                    }
                }
            },
        };
        this.calls = {
            callsStreamQueryPost: async (queryParams) => {
                let filteredCalls = this._calls.filter(call => call.project_id === queryParams.project_id);
                // Apply filters if any
                if (queryParams.filters) {
                    filteredCalls = filteredCalls.filter(call => {
                        return Object.entries(queryParams.filters || {}).every(([key, value]) => call[key] === value);
                    });
                }
                // Apply ordering
                if (queryParams.order_by) {
                    filteredCalls.sort((a, b) => {
                        if (a[queryParams.order_by] < b[queryParams.order_by])
                            return queryParams.order_dir === 'asc' ? -1 : 1;
                        if (a[queryParams.order_by] > b[queryParams.order_by])
                            return queryParams.order_dir === 'asc' ? 1 : -1;
                        return 0;
                    });
                }
                // Apply limit
                if (queryParams.limit) {
                    filteredCalls = filteredCalls.slice(0, queryParams.limit);
                }
                return {
                    calls: filteredCalls,
                    next_page_token: null, // Simplified: no pagination in this in-memory version
                };
            },
        };
        this.obj = {
            objCreateObjCreatePost: async (req) => {
                const now = new Date().toISOString();
                const digest = this.generateDigest(req.obj.val);
                const newObj = {
                    project_id: req.obj.project_id,
                    object_id: req.obj.object_id,
                    created_at: now,
                    deleted_at: null,
                    digest: digest,
                    version_index: 0,
                    is_latest: 1,
                    kind: req.obj.val._type || 'unknown',
                    base_object_class: req.obj.val._bases ? req.obj.val._bases[0] : null,
                    val: req.obj.val,
                };
                // Update version_index and is_latest for existing objects
                const existingObjs = this._objs.filter(obj => obj.project_id === req.obj.project_id &&
                    obj.object_id === req.obj.object_id);
                if (existingObjs.length > 0) {
                    newObj.version_index = existingObjs.length;
                    existingObjs.forEach(obj => (obj.is_latest = 0));
                }
                this._objs.push(newObj);
                return {
                    data: {
                        digest: digest,
                    },
                };
            },
        };
        this.file = {
            fileCreateFileCreatePost: async (data) => {
                const digest = this.generateDigest(await data.file.arrayBuffer());
                const newFile = {
                    project_id: data.project_id,
                    digest: digest,
                    content: data.file,
                };
                this._files.push(newFile);
                return {
                    digest: digest,
                };
            },
        };
        // ... other existing methods ...
    }
    generateDigest(data) {
        // In a real implementation, you'd want to use a proper hashing algorithm.
        // For simplicity, we're using uuidv7 here.
        return (0, uuidv7_1.uuidv7)();
    }
    _updateChangeTime() {
        this._lastChangeTime = Date.now();
        this._lastCallCount = this._calls.length;
    }
    /**
     * Waits for all pending operations to complete by checking if the call count
     * has stabilized for a minimum period. This is specifically designed for tests
     * where we need to wait for the weave client's async batch processing.
     *
     * @param stabilizationTime - How long to wait for no changes (default: 50ms)
     * @param maxWaitTime - Maximum time to wait before giving up (default: 2000ms)
     * @param minWaitTime - Minimum time to wait even if calls appear immediately (default: 20ms)
     * @returns Promise that resolves when operations have stabilized
     */
    async waitForPendingOperations(stabilizationTime = 50, maxWaitTime = 1500, minWaitTime = 10) {
        const startTime = Date.now();
        const initialCallCount = this._calls.length;
        let hasSeenNewCalls = false;
        // Wait minimum time to allow async operations to start
        await new Promise(resolve => setTimeout(resolve, minWaitTime));
        while (Date.now() - startTime < maxWaitTime) {
            const currentCallCount = this._calls.length;
            const timeSinceLastChange = Date.now() - this._lastChangeTime;
            // Track if we've seen new calls since we started waiting
            if (currentCallCount > initialCallCount) {
                hasSeenNewCalls = true;
            }
            // If we've seen new calls and they've been stable for the stabilization time, we're done
            if (hasSeenNewCalls &&
                currentCallCount === this._lastCallCount &&
                timeSinceLastChange >= stabilizationTime) {
                return;
            }
            // Update our tracking
            if (currentCallCount !== this._lastCallCount) {
                this._lastCallCount = currentCallCount;
                this._lastChangeTime = Date.now();
            }
            // Small delay before checking again
            await new Promise(resolve => setTimeout(resolve, 5));
        }
        // If we get here, we timed out, but don't throw - just proceed
        console.warn(`waitForPendingOperations timed out after ${maxWaitTime}ms. Calls: initial=${initialCallCount}, final=${this._calls.length}`);
    }
}
exports.InMemoryTraceServer = InMemoryTraceServer;
//# sourceMappingURL=inMemoryTraceServer.js.map