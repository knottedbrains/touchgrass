"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.op = op;
exports.isOp = isOp;
exports.createCallMethod = createCallMethod;
const call_1 = require("./call");
const clientApi_1 = require("./clientApi");
const constants_1 = require("./constants");
const urls_1 = require("./urls");
const warnOnce_1 = require("./utils/warnOnce");
/**
 * Checks if the arguments match the signature of a Stage 3 decorator.
 */
function isModernDecorator(args) {
    return (args.length === 2 &&
        args[1] &&
        typeof args[1] === 'object' &&
        'kind' in args[1]);
}
/**
 * Checks if the arguments match the signature of a Legacy decorator.
 */
function isLegacyDecorator(args) {
    return (args.length === 3 &&
        (typeof args[0] === 'object' || typeof args[0] === 'function') &&
        (typeof args[1] === 'string' || typeof args[1] === 'symbol') &&
        typeof args[2] === 'object');
}
/**
 * Checks if the arguments match the signature of a Decorator Factory.
 */
function isDecoratorFactory(args) {
    return (args.length === 1 &&
        typeof args[0] === 'object' &&
        !('prototype' in args[0]) && // Distinguish from class constructors
        !('bind' in args[0]) && // Distinguish from functions
        !Array.isArray(args[0]));
}
/**
 * Checks if the arguments match the signature of Function Binding.
 */
function isFunctionBinding(args) {
    return args.length >= 2 && typeof args[1] === 'function';
}
/**
 * Derives the name of the wrapped function.
 */
function deriveOpName(fn, options, context) {
    var _a, _b;
    const fnName = ((_a = options === null || options === void 0 ? void 0 : options.originalFunction) === null || _a === void 0 ? void 0 : _a.name) || fn.name || 'anonymous';
    let calculatedName = 'anonymous';
    if (options === null || options === void 0 ? void 0 : options.name) {
        calculatedName = options.name;
    }
    else if ((context === null || context === void 0 ? void 0 : context.kind) === 'method' && context.addInitializer) {
        calculatedName = '__pending__';
    }
    else if ((context === null || context === void 0 ? void 0 : context.kind) === 'method') {
        const className = ((_b = context.class) === null || _b === void 0 ? void 0 : _b.name) || 'anonymous';
        calculatedName = `${className}.${String(context.name)}`;
    }
    else if (options === null || options === void 0 ? void 0 : options.bindThis) {
        const className = Object.getPrototypeOf(options.bindThis).constructor.name || 'anonymous';
        calculatedName = `${className}.${fnName}`;
    }
    else {
        calculatedName = fnName;
    }
    return calculatedName;
}
/**
 * Creates the core wrapper function that handles call tracking and name setting.
 */
function createOpWrapper(fn, optionsAndContext) {
    var _a;
    const { context, ...options } = optionsAndContext;
    const call = new call_1.InternalCall();
    const opWrapper = async function (...params) {
        const client = (0, clientApi_1.getGlobalClient)();
        const thisArg = (options === null || options === void 0 ? void 0 : options.isDecorator) || (options === null || options === void 0 ? void 0 : options.shouldAdoptThis)
            ? this
            : options === null || options === void 0 ? void 0 : options.bindThis;
        if (!client) {
            (0, warnOnce_1.warnOnce)('weave-not-initialized', 'WARNING: Weave is not initialized, so calls wont be tracked.  Call `weave.init` to initialize before calling ops.  If this is intentional, you can safely ignore this warning.');
            return await fn.apply(thisArg, params);
        }
        const { currentCall, parentCall, newStack } = client.pushNewCall();
        const startTime = new Date();
        if (client.settings.shouldPrintCallLink && parentCall == null) {
            const domain = (0, urls_1.getGlobalDomain)();
            console.log(`${constants_1.TRACE_CALL_EMOJI} https://${domain}/${client.projectId}/r/call/${currentCall.callId}`);
        }
        const displayName = (options === null || options === void 0 ? void 0 : options.callDisplayName)
            ? options.callDisplayName(...params)
            : undefined;
        const opRefForCall = opWrapper;
        const startCallPromise = client.createCall(call, opRefForCall, params, options === null || options === void 0 ? void 0 : options.parameterNames, thisArg, currentCall, parentCall, startTime, displayName);
        try {
            let result = await client.runWithCallStack(newStack, async () => {
                return await fn.apply(thisArg, params);
            });
            // Stream handling
            if ((options === null || options === void 0 ? void 0 : options.streamReducer) &&
                typeof result === 'object' &&
                result !== null &&
                Symbol.asyncIterator in result) {
                const { initialStateFn, reduceFn, finalizeFn } = options.streamReducer;
                let state = initialStateFn();
                async function* WeaveIterator() {
                    try {
                        for await (const chunk of result) {
                            state = reduceFn(state, chunk);
                            yield chunk;
                        }
                    }
                    finally {
                        if (client) {
                            const endTime = new Date();
                            finalizeFn(state);
                            await client.finishCall(call, state, currentCall, parentCall, options === null || options === void 0 ? void 0 : options.summarize, endTime, startCallPromise);
                        }
                    }
                }
                const proxy = new Proxy(result, {
                    get: (target, prop) => {
                        if (prop === Symbol.asyncIterator) {
                            return WeaveIterator;
                        }
                        // allow all other properties to be accessed normally
                        return Reflect.get(target, prop);
                    },
                });
                return proxy;
            }
            else {
                // Non-stream handling
                const endTime = new Date();
                await client.finishCall(call, result, currentCall, parentCall, options === null || options === void 0 ? void 0 : options.summarize, endTime, startCallPromise);
                return result;
            }
        }
        catch (error) {
            const endTime = new Date();
            await client.finishCallWithException(call, error, currentCall, parentCall, endTime, startCallPromise);
            await client.waitForBatchProcessing();
            throw error;
        }
    };
    // Assign properties to the wrapper
    opWrapper.__name = deriveOpName(fn, options, context);
    opWrapper.__isOp = true;
    opWrapper.__wrappedFunction = (_a = options === null || options === void 0 ? void 0 : options.originalFunction) !== null && _a !== void 0 ? _a : fn;
    opWrapper.__boundThis = options === null || options === void 0 ? void 0 : options.bindThis;
    opWrapper.__parameterNames = options === null || options === void 0 ? void 0 : options.parameterNames;
    // We need to hook into modern decorators initializer to set the name
    if (opWrapper.__name === '__pending__' && (context === null || context === void 0 ? void 0 : context.addInitializer)) {
        context.addInitializer(function () {
            const actualClassName = context.static
                ? this.name
                : this.constructor.name;
            opWrapper.__name = `${actualClassName}.${String(context.name)}`;
        });
    }
    opWrapper.invoke = createCallMethod(opWrapper, call.proxy);
    return opWrapper;
}
// ---------------- Handler Functions ----------------
function handleModernDecorator(originalMethod, context, factoryOptions) {
    if (context.kind !== 'method') {
        throw new Error('@weave.op currently only supports method decorators (Stage 3)');
    }
    const options = {
        ...factoryOptions,
        isDecorator: true,
        originalFunction: originalMethod,
        context: context,
    };
    const wrapped = createOpWrapper(originalMethod, options);
    return wrapped;
}
function handleLegacyDecorator(target, propertyKey, descriptor, factoryOptions) {
    var _a;
    const originalFn = descriptor.value;
    if (typeof originalFn !== 'function') {
        throw new Error('@weave.op can only be used to decorate methods');
    }
    // Derive default legacy name
    let className = 'anonymous';
    if (target.constructor === Function) {
        // Static method
        className = target.name || 'anonymous';
    }
    else {
        // Instance method
        className = ((_a = target.constructor) === null || _a === void 0 ? void 0 : _a.name) || 'anonymous';
    }
    const derivedName = `${className}.${String(propertyKey)}`;
    const options = {
        ...factoryOptions,
        name: (factoryOptions === null || factoryOptions === void 0 ? void 0 : factoryOptions.name) || derivedName,
        isDecorator: true,
        originalFunction: originalFn,
    };
    const wrapped = createOpWrapper(originalFn, options);
    descriptor.value = wrapped;
    return descriptor;
}
function handleDecoratorFactory(factoryOptions) {
    return function (...decoratorArgs) {
        // Stage 3 Factory Usage
        if (isModernDecorator(decoratorArgs)) {
            const [originalMethod, context] = decoratorArgs;
            return handleModernDecorator(originalMethod, context, factoryOptions);
        }
        // Legacy Factory Usage
        if (isLegacyDecorator(decoratorArgs)) {
            const [target, propertyKey, descriptor] = decoratorArgs;
            return handleLegacyDecorator(target, propertyKey, descriptor, factoryOptions);
        }
        throw new Error('Invalid arguments passed to decorator generated by @weave.op factory');
    };
}
function handleFunctionBinding(thisArg, fn, options) {
    const boundFn = fn.bind(thisArg);
    // Cast boundFn to T since bind preserves the signature
    return createOpWrapper(boundFn, {
        ...options,
        originalFunction: fn,
        bindThis: thisArg,
    });
}
function op(...args) {
    // Stage 3 Decorator
    if (isModernDecorator(args)) {
        const [originalMethod, context] = args;
        // Cast originalMethod to a specific function type before passing
        return handleModernDecorator(originalMethod, context);
    }
    // Legacy Decorator
    if (isLegacyDecorator(args)) {
        const [target, propertyKey, descriptor] = args;
        // Legacy decorators modify the descriptor and return it
        return handleLegacyDecorator(target, propertyKey, descriptor);
    }
    // Decorator Factory
    if (isDecoratorFactory(args)) {
        const [options] = args;
        return handleDecoratorFactory(options);
    }
    // Function Binding
    if (isFunctionBinding(args)) {
        const [thisArg, fn, options] = args;
        return handleFunctionBinding(thisArg, fn, options);
    }
    const [fn, options] = args;
    return createOpWrapper(fn, typeof options === 'object' ? options : {});
}
function isOp(fn) {
    return (fn === null || fn === void 0 ? void 0 : fn.__isOp) === true;
}
function createCallMethod(opWrapper, callProxy) {
    return async function call(...args) {
        return [await opWrapper.apply(this, args), callProxy];
    };
}
//# sourceMappingURL=op.js.map