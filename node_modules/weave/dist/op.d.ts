import { Call } from './call';
import { Op, OpOptions, CallMethod } from './opType';
export interface MethodDecoratorContext {
    kind: 'method';
    name: string | symbol;
    static?: boolean;
    class?: Function;
    addInitializer?(initializer: () => void): void;
    private?: boolean;
    access?: {
        has(object: object): boolean;
        get(object: object): Function;
    };
    metadata?: any;
}
export declare function op<T extends (...args: any[]) => any>(fn: T, options?: OpOptions<T>): Op<T>;
export declare function op<T extends (...args: any[]) => any>(thisArg: any, fn: T, options?: OpOptions<T>): Op<T>;
export declare function op(target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor<any>): TypedPropertyDescriptor<any>;
export declare function op<T extends (...args: any[]) => any>(value: T, context: MethodDecoratorContext): Op<T>;
export declare function op(options: Partial<OpOptions<any>>): MethodDecorator;
export declare function isOp(fn: any): fn is Op<any>;
export declare function createCallMethod<F extends (...args: any[]) => any>(opWrapper: (this: any, ...args: Parameters<F>) => Promise<Awaited<ReturnType<F>>>, callProxy: Call): CallMethod<F>;
//# sourceMappingURL=op.d.ts.map