"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InternalCall = exports.CallState = void 0;
const clientApi_1 = require("./clientApi");
const MAX_DISPLAY_NAME_LENGTH = 1000;
var CallState;
(function (CallState) {
    CallState[CallState["uninitialized"] = 0] = "uninitialized";
    CallState[CallState["pending"] = 1] = "pending";
    CallState[CallState["finished"] = 2] = "finished";
    CallState[CallState["failed"] = 3] = "failed";
})(CallState || (exports.CallState = CallState = {}));
class InternalCall {
    constructor() {
        this._state = CallState.uninitialized;
        this.callSchema = {};
    }
    async setDisplayName(displayName) {
        const elidedDisplayName = elideDisplayName(displayName);
        this.callSchema.display_name = elidedDisplayName;
        if ([CallState.pending, CallState.uninitialized].includes(this._state)) {
            // nothing needs to be done here, the call will be updated when it is finished
            return;
        }
        const client = (0, clientApi_1.getGlobalClient)();
        if (!client) {
            throw new Error('Weave is not initialized');
        }
        await client.updateCall(this.callSchema.id, elidedDisplayName);
    }
    updateWithCallSchemaData(callSchemaExchangeData) {
        Object.assign(this.callSchema, callSchemaExchangeData);
    }
    // This proxy is used to access the call schema properties, we don't directly expose the InternalCall instance
    get proxy() {
        return new Proxy(this.callSchema, buildProxyHandlers(this.callSchema, this));
    }
    set state(state) {
        this._state = state;
    }
}
exports.InternalCall = InternalCall;
function buildProxyHandlers(callSchema, internalCall) {
    return {
        get(target, prop) {
            if (prop === 'toJSON') {
                return (...args) => JSON.stringify(callSchema, ...args);
            }
            if (prop === 'setDisplayName') {
                return internalCall.setDisplayName.bind(internalCall);
            }
            // If the property exists on the call schema, return it
            if (Reflect.has(internalCall.callSchema, prop)) {
                return Reflect.get(internalCall.callSchema, prop);
            }
            return undefined;
        },
        set(target, prop, value) {
            // Disallow setting properties on the call schema
            return false;
        },
    };
}
function elideDisplayName(name) {
    if (name.length > MAX_DISPLAY_NAME_LENGTH) {
        console.warn(`Display name ${name} is longer than ${MAX_DISPLAY_NAME_LENGTH} characters.  It will be truncated!`);
        return name.slice(0, MAX_DISPLAY_NAME_LENGTH - 3) + '...';
    }
    return name;
}
//# sourceMappingURL=call.js.map