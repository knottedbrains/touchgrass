"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WeaveClient = void 0;
const async_hooks_1 = require("async_hooks");
const fs = __importStar(require("fs"));
const uuidv7_1 = require("uuidv7");
const constants_1 = require("./constants");
const digest_1 = require("./digest");
const media_1 = require("./media");
const opType_1 = require("./opType");
const settings_1 = require("./settings");
const table_1 = require("./table");
const userAgent_1 = require("./utils/userAgent");
const weaveObject_1 = require("./weaveObject");
const call_1 = require("./call");
const WEAVE_ERRORS_LOG_FNAME = 'weaveErrors.log';
function generateTraceId() {
    return (0, uuidv7_1.uuidv7)();
}
function generateCallId() {
    return (0, uuidv7_1.uuidv7)();
}
class CallStack {
    constructor(stack = []) {
        this.stack = stack;
    }
    peek() {
        var _a;
        return (_a = this.stack[this.stack.length - 1]) !== null && _a !== void 0 ? _a : null;
    }
    pushNewCall() {
        var _a;
        const parentCall = this.stack[this.stack.length - 1];
        const callId = generateCallId();
        const traceId = (_a = parentCall === null || parentCall === void 0 ? void 0 : parentCall.traceId) !== null && _a !== void 0 ? _a : generateTraceId();
        const newCall = { callId, traceId, childSummary: {} };
        const newStack = new CallStack([...this.stack, newCall]);
        return { currentCall: newCall, parentCall, newStack };
    }
}
// We count characters item by item, and try to limit batches to about this size.
const MAX_BATCH_SIZE_CHARS = 10 * 1024 * 1024;
class WeaveClient {
    constructor(traceServerApi, wandbServerApi, projectId, settings = new settings_1.Settings()) {
        this.traceServerApi = traceServerApi;
        this.wandbServerApi = wandbServerApi;
        this.projectId = projectId;
        this.settings = settings;
        this.stackContext = new async_hooks_1.AsyncLocalStorage();
        this.callQueue = [];
        this.batchProcessTimeout = null;
        this.isBatchProcessing = false;
        this.batchProcessingPromises = new Set();
        this.BATCH_INTERVAL = 200;
        this.errorCount = 0;
        this.MAX_ERRORS = 10;
    }
    scheduleBatchProcessing() {
        if (this.batchProcessTimeout || this.isBatchProcessing)
            return;
        const promise = new Promise(resolve => {
            this.batchProcessTimeout = setTimeout(() => this.processBatch().then(resolve), this.BATCH_INTERVAL);
        });
        this.batchProcessingPromises.add(promise);
        promise.finally(() => {
            this.batchProcessingPromises.delete(promise);
        });
    }
    async waitForBatchProcessing() {
        while (this.batchProcessingPromises.size > 0) {
            await Promise.all(this.batchProcessingPromises);
        }
    }
    async processBatch() {
        if (this.isBatchProcessing || this.callQueue.length === 0) {
            this.batchProcessTimeout = null;
            return;
        }
        this.isBatchProcessing = true;
        let batchToProcess = [];
        let currentBatchSize = 0;
        while (this.callQueue.length > 0 &&
            currentBatchSize < MAX_BATCH_SIZE_CHARS) {
            const item = this.callQueue.shift();
            if (item === undefined) {
                throw new Error('Call queue is empty');
            }
            const itemSize = JSON.stringify(item).length;
            if (itemSize > MAX_BATCH_SIZE_CHARS) {
                fs.appendFileSync(WEAVE_ERRORS_LOG_FNAME, `Item size ${itemSize} exceeds max batch size ${MAX_BATCH_SIZE_CHARS}.  Item: ${JSON.stringify(item)}\n`);
            }
            if (currentBatchSize + itemSize <= MAX_BATCH_SIZE_CHARS) {
                batchToProcess.push(item);
                currentBatchSize += itemSize;
            }
            else {
                // doesn't fit, put it back
                this.callQueue.unshift(item);
                break;
            }
        }
        if (batchToProcess.length === 0) {
            this.batchProcessTimeout = null;
            return;
        }
        this.isBatchProcessing = true;
        const batchReq = {
            batch: batchToProcess.map(item => ({
                mode: item.mode,
                req: item.data,
            })),
        };
        try {
            await this.traceServerApi.call.callStartBatchCallUpsertBatchPost(batchReq);
        }
        catch (error) {
            console.error('Error processing batch:', error);
            this.errorCount++;
            fs.appendFileSync(WEAVE_ERRORS_LOG_FNAME, `Error processing batch: ${error}\n`);
            // Put failed items back at the front of the queue
            this.callQueue.unshift(...batchToProcess);
            // Exit if we have too many errors
            if (this.errorCount > this.MAX_ERRORS) {
                console.error(`Exceeded max errors: ${this.MAX_ERRORS}; exiting`);
                process.exit(1);
            }
        }
        finally {
            this.isBatchProcessing = false;
            this.batchProcessTimeout = null;
            if (this.callQueue.length > 0) {
                this.scheduleBatchProcessing();
            }
        }
    }
    publish(obj, objId) {
        if (obj.__savedRef) {
            return obj.__savedRef;
        }
        else if (obj instanceof weaveObject_1.WeaveObject) {
            return this.saveObject(obj, objId);
        }
        else if ((0, opType_1.isOp)(obj)) {
            return this.saveOp(obj);
        }
        else {
            return this.saveArbitrary(obj, objId);
        }
    }
    async getCall(callId, includeCosts = false) {
        const calls = await this.getCalls({ call_ids: [callId] }, includeCosts);
        if (calls.length === 0) {
            throw new Error(`Call not found: ${callId}`);
        }
        return calls[0];
    }
    async getCalls(filter = {}, includeCosts = false, limit = 1000) {
        const calls = [];
        const iterator = this.getCallsIterator(filter, includeCosts, limit);
        for await (const call of iterator) {
            const internalCall = new call_1.InternalCall();
            internalCall.updateWithCallSchemaData(call);
            calls.push(internalCall.proxy);
        }
        return calls;
    }
    async *getCallsIterator(filter = {}, includeCosts = false, limit = 1000) {
        const resp = await this.traceServerApi.calls.callsQueryStreamCallsStreamQueryPost({
            project_id: this.projectId,
            filter,
            include_costs: includeCosts,
            limit,
        });
        const reader = resp.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';
        while (true) {
            const { value, done } = await reader.read();
            if (done)
                break;
            buffer += decoder.decode(value, { stream: true });
            const lines = buffer.split('\n');
            buffer = lines.pop() || '';
            for (const line of lines) {
                if (line.trim()) {
                    try {
                        yield JSON.parse(line);
                    }
                    catch (error) {
                        console.error('Error parsing JSON:', error, 'Line:', line);
                    }
                }
            }
        }
        if (buffer.trim()) {
            try {
                yield JSON.parse(buffer);
            }
            catch (error) {
                console.error('Error parsing JSON:', error, 'Remaining data:', buffer);
            }
        }
    }
    async get(ref) {
        var _a, _b;
        let val;
        let dataObj;
        try {
            const res = await this.traceServerApi.obj.objReadObjReadPost({
                project_id: ref.projectId,
                object_id: ref.objectId,
                digest: ref.digest,
            });
            dataObj = res.data.obj;
            val = dataObj.val;
        }
        catch (error) {
            if (error instanceof Error && error.message.includes('404')) {
                throw new Error(`Unable to find object for ref uri: ${ref.uri()}`);
            }
            throw error;
        }
        const t = val === null || val === void 0 ? void 0 : val._type;
        if (t == 'StringPrompt') {
            const { StringPrompt } = await Promise.resolve().then(() => __importStar(require('./prompt')));
            const { content, description, name } = val;
            let obj = new StringPrompt({
                name,
                description,
                content,
            });
            obj.__savedRef = ref;
            return obj;
        }
        if (t == 'MessagesPrompt') {
            const { MessagesPrompt } = await Promise.resolve().then(() => __importStar(require('./prompt')));
            const { description, messages, name } = val;
            let obj = new MessagesPrompt({
                name,
                description,
                messages,
            });
            obj.__savedRef = ref;
            return obj;
        }
        if (t == 'Dataset') {
            // Avoid circular dependency
            const { Dataset } = await Promise.resolve().then(() => __importStar(require('./dataset')));
            const { description, rows, name } = val;
            let obj = new Dataset({
                name: name || dataObj.id,
                description,
                rows,
            });
            obj.__savedRef = ref;
            // TODO: The table row refs are not correct
            return obj;
        }
        else if (t == 'Table') {
            const { rows } = val;
            let obj = new table_1.Table(rows);
            obj.__savedRef = ref;
            return obj;
        }
        else if (t == 'CustomWeaveType') {
            const typeName = val.weave_type.type;
            if (typeName == 'PIL.Image.Image') {
                let loadedFiles = {};
                for (const [name, digest] of Object.entries(val.files)) {
                    try {
                        const fileContent = await this.traceServerApi.file.fileContentFileContentPost({
                            project_id: this.projectId,
                            digest: digest,
                        });
                        loadedFiles[name] = (_a = fileContent.data) === null || _a === void 0 ? void 0 : _a.content;
                    }
                    catch (error) {
                        console.error('Error loading file:', error);
                    }
                }
                // TODO: Implement getting img back as buffer
                return 'Coming soon!';
            }
            else if (typeName == 'wave.Wave_read') {
                let loadedFiles = {};
                for (const [name, digest] of Object.entries(val.files)) {
                    try {
                        const fileContent = await this.traceServerApi.file.fileContentFileContentPost({
                            project_id: this.projectId,
                            digest: digest,
                        });
                        loadedFiles[name] = (_b = fileContent.data) === null || _b === void 0 ? void 0 : _b.content;
                    }
                    catch (error) {
                        console.error('Error loading file:', error);
                    }
                }
                // TODO: Implement getting audio back as buffer
                return 'Coming soon!';
            }
        }
        return val;
    }
    // save* methods attached __savedRef promises to their values. These must
    // be synchronous, so we can guarantee that calling savedWeaveValues
    // immediately makes __savedRef promises available.
    saveArbitrary(obj, objId) {
        if (obj.__savedRef) {
            return obj.__savedRef;
        }
        const ref = (async () => {
            if (!objId) {
                objId = (0, uuidv7_1.uuidv7)();
            }
            const serializedObj = await this.serializedVal(obj);
            const response = await this.traceServerApi.obj.objCreateObjCreatePost({
                obj: {
                    project_id: this.projectId,
                    object_id: objId,
                    val: serializedObj,
                },
            });
            return new weaveObject_1.ObjectRef(this.projectId, objId, response.data.digest);
        })();
        obj.__savedRef = ref;
        return ref;
    }
    saveObject(obj, objId) {
        if (obj.__savedRef) {
            return Promise.resolve(obj.__savedRef);
        }
        for (const [key, value] of Object.entries(obj)) {
            this.saveWeaveValues(value);
        }
        obj.__savedRef = (async () => {
            const classChain = (0, weaveObject_1.getClassChain)(obj);
            const className = classChain[0];
            if (!objId) {
                objId = objectNameToId(obj.name);
            }
            let saveAttrs = obj.saveAttrs();
            saveAttrs = await this.serializedVal(saveAttrs);
            // Frontend does this overly specific check for datasets, so we need to add both _type and _class_name
            // for now.
            //   data._type === 'Dataset' &&
            //   data._class_name === 'Dataset' &&
            //   _.isEqual(data._bases, ['Object', 'BaseModel'])
            const saveValue = {
                _type: className,
                _class_name: className,
                _bases: classChain.slice(1),
                ...saveAttrs,
            };
            const response = await this.traceServerApi.obj.objCreateObjCreatePost({
                obj: {
                    project_id: this.projectId,
                    object_id: objId,
                    val: saveValue,
                },
            });
            const ref = new weaveObject_1.ObjectRef(this.projectId, objId, response.data.digest);
            return ref;
        })();
        return obj.__savedRef;
    }
    saveTable(table) {
        if (table.__savedRef) {
            return;
        }
        table.__savedRef = (async () => {
            const rowsWithoutRefs = table.rows.map(row => {
                return { ...row, __savedRef: undefined };
            });
            const rows = await this.serializedVal(rowsWithoutRefs);
            const response = await this.traceServerApi.table.tableCreateTableCreatePost({
                table: {
                    project_id: this.projectId,
                    rows,
                },
            });
            const ref = new table_1.TableRef(this.projectId, response.data.digest);
            return ref;
        })();
        const tableQueryPromise = (async () => {
            const tableRef = await table.__savedRef;
            const tableQueryRes = await this.traceServerApi.table.tableQueryTableQueryPost({
                project_id: this.projectId,
                digest: tableRef === null || tableRef === void 0 ? void 0 : tableRef.digest,
            });
            return {
                tableDigest: tableRef === null || tableRef === void 0 ? void 0 : tableRef.digest,
                tableQueryResult: tableQueryRes.data,
            };
        })();
        for (let i = 0; i < table.rows.length; i++) {
            const row = table.rows[i];
            row.__savedRef = (async () => {
                const { tableDigest, tableQueryResult } = await tableQueryPromise;
                return new table_1.TableRowRef(this.projectId, tableDigest, tableQueryResult.rows[i].digest);
            })();
        }
    }
    /**
     * Recursively save a Weave value, attaching __savedRef Promises to
     * nested value that gets its own ref.
     *
     * This function must be synchronous, so that code that does ref-tracking
     * (currently only Dataset/DatasetRow in the js client) has refs
     * available immediately.
     */
    saveWeaveValues(val) {
        if (Array.isArray(val)) {
            val.map(item => this.saveWeaveValues(item));
        }
        else if (val != null && val.__savedRef) {
            return;
        }
        else if (val instanceof weaveObject_1.WeaveObject) {
            this.saveObject(val);
        }
        else if (val instanceof table_1.Table) {
            this.saveTable(val);
        }
        else if ((0, media_1.isWeaveImage)(val)) {
        }
        else if ((0, media_1.isWeaveAudio)(val)) {
        }
        else if ((0, opType_1.isOp)(val)) {
            this.saveOp(val);
        }
        else if (typeof val === 'object' && val !== null) {
            for (const [key, value] of Object.entries(val)) {
                this.saveWeaveValues(value);
            }
        }
    }
    // serialize* methods are async, and return the serialized value
    // of a Weave value.
    async serializedFileBlob(typeName, fileName, fileContent) {
        const buffer = await fileContent.arrayBuffer().then(Buffer.from);
        const digest = (0, digest_1.computeDigest)(buffer);
        const placeholder = {
            _type: 'CustomWeaveType',
            weave_type: { type: typeName },
            files: {
                [fileName]: digest,
            },
            load_op: 'NO_LOAD_OP',
        };
        try {
            await this.traceServerApi.file.fileCreateFileCreatePost({
                project_id: this.projectId,
                // @ts-ignore
                file: fileContent,
            });
        }
        catch (error) {
            console.error('Error saving file:', error);
        }
        return placeholder;
    }
    async serializedImage(imageData, imageType = media_1.DEFAULT_IMAGE_TYPE) {
        const blob = new Blob([imageData], { type: `image/${imageType}` });
        return this.serializedFileBlob('PIL.Image.Image', 'image.png', blob);
    }
    async serializedAudio(audioData, audioType = media_1.DEFAULT_AUDIO_TYPE) {
        const blob = new Blob([audioData], { type: `audio/${audioType}` });
        return this.serializedFileBlob('wave.Wave_read', 'audio.wav', blob);
    }
    /**
     * Get the serialized value of a Weave value, by recursively
     * resolving any __savedRef promises to their uri().
     *
     * This function is asynchronous, and must be called after saveWeaveValues
     * has been called on the value.
     */
    async serializedVal(val) {
        if (Array.isArray(val)) {
            return Promise.all(val.map(async (item) => this.serializedVal(item)));
        }
        else if (val != null && val.__savedRef) {
            return (await val.__savedRef).uri();
        }
        else if ((0, media_1.isWeaveImage)(val)) {
            return await this.serializedImage(val.data, val.imageType);
        }
        else if ((0, media_1.isWeaveAudio)(val)) {
            return await this.serializedAudio(val.data, val.audioType);
        }
        else if (val instanceof weaveObject_1.WeaveObject) {
            throw new Error('Programming error:  WeaveObject not saved');
        }
        else if (val instanceof table_1.Table) {
            throw new Error('Programming error: Table not saved');
        }
        else if ((0, opType_1.isOp)(val)) {
            throw new Error('Programming error: Op not saved');
        }
        else if (typeof val === 'object' && val !== null) {
            const result = {};
            for (const [key, value] of Object.entries(val)) {
                result[key] = await this.serializedVal(value);
            }
            return result;
        }
        else {
            return val;
        }
    }
    saveCallStart(callStart) {
        this.callQueue.push({ mode: 'start', data: { start: callStart } });
        this.scheduleBatchProcessing();
    }
    saveCallEnd(callEnd) {
        this.callQueue.push({ mode: 'end', data: { end: callEnd } });
        this.scheduleBatchProcessing();
    }
    getCallStack() {
        return this.stackContext.getStore() || new CallStack();
    }
    pushNewCall() {
        return this.getCallStack().pushNewCall();
    }
    runWithCallStack(callStack, fn) {
        return this.stackContext.run(callStack, fn);
    }
    async paramsToCallInputs(params, thisArg, parameterNames) {
        let inputs = {};
        // Add 'self' first if thisArg is a WeaveObject
        if (thisArg instanceof weaveObject_1.WeaveObject) {
            inputs['self'] = thisArg;
        }
        if (parameterNames === 'useParam0Object') {
            inputs = { ...inputs, ...params[0] };
        }
        else if (parameterNames) {
            params.forEach((arg, index) => {
                inputs[parameterNames[index]] = arg;
            });
        }
        else {
            params.forEach((arg, index) => {
                inputs[`arg${index}`] = arg;
            });
        }
        this.saveWeaveValues(inputs);
        return await this.serializedVal(inputs);
    }
    async saveOp(op, objId) {
        if (op.__savedRef) {
            return op.__savedRef;
        }
        op.__savedRef = (async () => {
            const resolvedObjId = objId || (0, opType_1.getOpName)(op);
            const opFn = (0, opType_1.getOpWrappedFunction)(op);
            const formattedOpFn = await maybeFormatCode(opFn.toString());
            const saveValue = await this.serializedFileBlob('Op', 'obj.py', new Blob([formattedOpFn]));
            const response = await this.traceServerApi.obj.objCreateObjCreatePost({
                obj: {
                    project_id: this.projectId,
                    object_id: resolvedObjId,
                    val: saveValue,
                },
            });
            const ref = new opType_1.OpRef(this.projectId, resolvedObjId, response.data.digest);
            return ref;
        })();
        return op.__savedRef;
    }
    async createCall(internalCall, opRef, params, parameterNames, thisArg, currentCall, parentCall, startTime, displayName) {
        const inputs = await this.paramsToCallInputs(params, thisArg, parameterNames);
        if ((0, opType_1.isOp)(opRef)) {
            this.saveOp(opRef);
            opRef = await opRef.__savedRef;
        }
        const startReq = {
            project_id: this.projectId,
            id: currentCall.callId,
            op_name: opRef.uri(),
            trace_id: currentCall.traceId,
            parent_id: parentCall === null || parentCall === void 0 ? void 0 : parentCall.callId,
            started_at: startTime.toISOString(),
            display_name: displayName,
            attributes: {
                weave: {
                    client_version: userAgent_1.packageVersion,
                    source: 'js-sdk',
                },
            },
            inputs,
        };
        internalCall.updateWithCallSchemaData(startReq);
        internalCall.state = call_1.CallState.pending;
        return this.saveCallStart(startReq);
    }
    async finishCall(call, result, currentCall, parentCall, summarize, endTime, startCallPromise) {
        // Important to do this first before any awaiting, so we're guaranteed that children
        // summaries are processed before parents!
        const mergedSummary = processSummary(result, summarize, currentCall, parentCall);
        // ensure end is logged after start is logged
        await startCallPromise;
        this.saveWeaveValues(result);
        result = await this.serializedVal(result);
        const callSchemaExchangeData = {
            ended_at: endTime.toISOString(),
            output: result,
            summary: mergedSummary,
        };
        this.saveCallEnd({
            project_id: this.projectId,
            id: currentCall.callId,
            ...callSchemaExchangeData,
            // User might change the display name of the call after the call has started.
            // take this into account when logging the end call.
            ...(call.callSchema.display_name === null
                ? null
                : { display_name: call.callSchema.display_name }),
        });
        call.updateWithCallSchemaData(callSchemaExchangeData);
        call.state = call_1.CallState.finished;
    }
    async finishCallWithException(call, error, currentCall, parentCall, endTime, startCallPromise) {
        const mergedSummary = processSummary(null, undefined, currentCall, parentCall);
        // ensure end is logged after start is logged
        await startCallPromise;
        const callSchemaExchangeData = {
            ended_at: endTime.toISOString(),
            output: null,
            summary: mergedSummary,
            exception: error instanceof Error ? error.message : String(error),
        };
        this.saveCallEnd({
            project_id: this.projectId,
            id: currentCall.callId,
            ...callSchemaExchangeData,
            // User might change the display name of the call after the call has started.
            // take this into account when logging the end call.
            ...(call.callSchema.display_name === null
                ? null
                : { display_name: call.callSchema.display_name }),
        });
        call.updateWithCallSchemaData(callSchemaExchangeData);
        call.state = call_1.CallState.failed;
    }
    async updateCall(callId, displayName) {
        await this.traceServerApi.call.callUpdateCallUpdatePost({
            project_id: this.projectId,
            call_id: callId,
            display_name: displayName,
        });
    }
}
exports.WeaveClient = WeaveClient;
/**
 * Merges two summary objects, combining their values.
 *
 * @param left - The first summary object to merge.
 * @param right - The second summary object to merge.
 * @returns A new summary object containing the merged values.
 *
 * This function performs a deep merge of two summary objects:
 * - For numeric values, it adds them together.
 * - For nested objects, it recursively merges them.
 * - For other types, the left value "wins".
 */
function mergeSummaries(left, right) {
    const result = { ...right };
    for (const [key, leftValue] of Object.entries(left)) {
        if (key in result) {
            if (typeof leftValue === 'number' && typeof result[key] === 'number') {
                result[key] = leftValue + result[key];
            }
            else if (leftValue != null &&
                typeof leftValue === 'object' &&
                result[key] != null &&
                typeof result[key] === 'object') {
                result[key] = mergeSummaries(leftValue, result[key]);
            }
            else {
                result[key] = leftValue;
            }
        }
        else {
            result[key] = leftValue;
        }
    }
    return result;
}
function processSummary(result, summarize, currentCall, parentCall) {
    let ownSummary = summarize && result != null ? summarize(result) : {};
    if (ownSummary.usage) {
        for (const model in ownSummary.usage) {
            if (typeof ownSummary.usage[model] === 'object') {
                ownSummary.usage[model] = {
                    requests: 1,
                    ...ownSummary.usage[model],
                };
            }
        }
    }
    const mergedSummary = mergeSummaries(ownSummary, currentCall.childSummary);
    if (parentCall) {
        parentCall.childSummary = mergeSummaries(mergedSummary, parentCall.childSummary);
    }
    return mergedSummary;
}
async function maybeFormatCode(code) {
    return code;
    //   try {
    //     const prettier = await import('prettier');
    //     return prettier.format(code, { parser: 'babel' });
    //   } catch (error) {
    //     // prettier not available or formatting failed, just use the original string
    //     return code;
    //   }
}
function objectNameToId(name) {
    // Replaces any non-alphanumeric characters with a single dash and removes
    // any leading or trailing dashes. This is more restrictive than the DB
    // constraints and can be relaxed if needed.
    let res = name.replace(/[^\w._]+/g, '-'); // non-words
    res = res.replace(/([._-]{2,})+/g, '-'); // multiple separators
    res = res.replace(/^[-_]+|[-_]+$/g, ''); // leading/trailing separators
    if (!res) {
        throw new Error(`Invalid object name: ${name}`);
    }
    // Truncate if too long
    if (res.length > constants_1.MAX_OBJECT_NAME_LENGTH) {
        res = res.slice(0, constants_1.MAX_OBJECT_NAME_LENGTH);
    }
    return res;
}
//# sourceMappingURL=weaveClient.js.map