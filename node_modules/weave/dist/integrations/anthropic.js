"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.commonPatchAnthropic = commonPatchAnthropic;
exports.instrumentAnthropic = instrumentAnthropic;
const instrumentations_1 = require("./instrumentations");
const op_1 = require("../op");
const streamReducer = {
    initialStateFn: () => ({
        messages: [],
    }),
    reduceFn: (state, chunk) => {
        var _a;
        let lastMessage;
        switch (chunk.type) {
            case 'message_start':
                state.messages.push({ ...chunk.message, content: [] });
                break;
            case 'message_delta':
                lastMessage = state.messages[state.messages.length - 1];
                Object.assign(lastMessage, chunk.delta);
                Object.assign((_a = lastMessage.usage) !== null && _a !== void 0 ? _a : {}, chunk.usage);
                break;
            case 'content_block_start':
                lastMessage = state.messages[state.messages.length - 1];
                lastMessage.content.push(chunk.content_block);
                break;
            case 'content_block_delta':
                lastMessage = state.messages[state.messages.length - 1];
                lastMessage.content.push(chunk.delta);
                break;
        }
        return state;
    },
    finalizeFn: () => {
        // no-op
    },
};
function summarizer(result) {
    var _a, _b;
    // Non-streaming mode
    if (result.usage != null && result.usage != null) {
        return {
            usage: {
                [result.model]: result.usage,
            },
        };
    }
    // Streaming mode
    if (result.messages != null && result.messages.length > 0) {
        const usage = {};
        for (const message of result.messages) {
            const { usage: messageUsage, model } = message;
            if (model == undefined || usage == undefined) {
                continue;
            }
            if (usage[model] == null) {
                usage[model] = {
                    input_tokens: 0,
                    output_tokens: 0,
                };
            }
            usage[model].input_tokens += (_a = messageUsage === null || messageUsage === void 0 ? void 0 : messageUsage.input_tokens) !== null && _a !== void 0 ? _a : 0;
            usage[model].output_tokens += (_b = messageUsage === null || messageUsage === void 0 ? void 0 : messageUsage.output_tokens) !== null && _b !== void 0 ? _b : 0;
        }
        return {
            usage,
        };
    }
    return {};
}
function patchAnthropicMessagesCreate(exports) {
    const originalCreate = exports.Anthropic.Messages.prototype.create;
    exports.Anthropic.Messages.prototype.create = new Proxy(originalCreate, {
        apply: (target, thisArg, args) => {
            const [inputOptions] = args;
            const isStream = inputOptions.stream;
            const weaveOpOptions = {
                name: 'create',
                shouldAdoptThis: true,
                originalFunction: originalCreate,
                summarize: summarizer,
                ...(isStream ? { streamReducer } : null),
            };
            let result;
            let weaveOp = (0, op_1.op)(() => {
                result = originalCreate.apply(thisArg, args);
                return result;
            }, weaveOpOptions);
            const weaveResult = weaveOp.apply(thisArg, args);
            result.then = (onFulfilled, onRejected) => {
                // weaveResult is going to carry the patched iterator, override the original result with it
                return weaveResult.then(onFulfilled, onRejected);
            };
            return result;
        },
    });
}
function patchStreamHelper(exports) {
    const originalStream = exports.Anthropic.Messages.prototype.stream;
    async function StreamWrapper(context, ...args) {
        const stream = originalStream.apply(this, args);
        context.result = stream;
        return new Promise((resolve, reject) => {
            stream.on('end', () => {
                resolve({ messages: stream.messages });
            });
            stream.on('error', reject);
        });
    }
    const options = {
        name: 'stream',
        shouldAdoptThis: true,
        summarize: summarizer,
        originalFunction: originalStream,
    };
    const weaveOp = (0, op_1.op)(StreamWrapper, options);
    exports.Anthropic.Messages.prototype.stream = new Proxy(originalStream, {
        apply: (target, thisArg, args) => {
            const box = { result: null };
            weaveOp.apply(thisArg, [box, ...args]);
            return box.result;
        },
    });
}
const batchStreamReducer = {
    initialStateFn: streamReducer.initialStateFn,
    reduceFn: (state, chunk) => {
        // batch message type
        if (typeof chunk.result == 'object' && chunk.result != null) {
            state.messages.push(chunk.result.message);
        }
        return state;
    },
    finalizeFn: state => {
        // no-op
    },
};
function patchBatchApi(exports) {
    // patch create
    const originalBatchCreate = exports.Anthropic.Messages.Batches.prototype.create;
    const weaveOp = (0, op_1.op)(originalBatchCreate, {
        name: 'create',
        shouldAdoptThis: true,
        originalFunction: originalBatchCreate,
    });
    exports.Anthropic.Messages.Batches.prototype.create = weaveOp;
    // patch retrieve
    const originalBatchRetrieve = exports.Anthropic.Messages.Batches.prototype.retrieve;
    const weaveOpRetrieve = (0, op_1.op)(originalBatchRetrieve, {
        name: 'retrieve',
        shouldAdoptThis: true,
        originalFunction: originalBatchRetrieve,
    });
    exports.Anthropic.Messages.Batches.prototype.retrieve = weaveOpRetrieve;
    // patch results
    const originalBatchResults = exports.Anthropic.Messages.Batches.prototype.results;
    const weaveOpResults = (0, op_1.op)(originalBatchResults, {
        name: 'results',
        shouldAdoptThis: true,
        summarize: summarizer,
        originalFunction: originalBatchResults,
        streamReducer: batchStreamReducer,
    });
    exports.Anthropic.Messages.Batches.prototype.results = weaveOpResults;
}
function commonPatchAnthropic(exports) {
    patchAnthropicMessagesCreate(exports);
    patchStreamHelper(exports);
    patchBatchApi(exports);
    return exports;
}
function instrumentAnthropic() {
    (0, instrumentations_1.addCJSInstrumentation)({
        moduleName: '@anthropic-ai/sdk',
        subPath: 'index.js',
        version: '>= 0.52.0',
        hook: commonPatchAnthropic,
    });
    (0, instrumentations_1.addESMInstrumentation)({
        moduleName: '@anthropic-ai/sdk',
        version: '>= 0.52.0',
        hook: commonPatchAnthropic,
    });
}
//# sourceMappingURL=anthropic.js.map