export declare const openAIStreamReducer: {
    initialStateFn: () => {
        id: string;
        object: string;
        created: number;
        model: string;
        choices: {
            index: number;
            message: {
                role: string;
                content: string;
                function_call: null;
            };
            finish_reason: null;
        }[];
        usage: null;
    };
    reduceFn: (state: any, chunk: any) => any;
    finalizeFn: () => void;
};
export declare function makeOpenAIChatCompletionsOp(originalCreate: any, name: string): import("../opType").Op<(...args: Parameters<typeof originalCreate>) => any>;
export declare function makeOpenAIImagesGenerateOp(originalGenerate: any): import("../opType").Op<(...args: Parameters<typeof originalGenerate>) => Promise<any>>;
import { StreamReducer } from '../opType';
export type Response = {
    id: string;
    object: string;
    created_at: number;
    status: string;
    background: boolean;
    error: any;
    incomplete_details: any;
    instructions: string;
    max_output_tokens: any;
    model: string;
    output: any;
    parallel_tool_calls: boolean;
    previous_response_id: string | null;
    reasoning: {
        effort: any;
        summary: any;
    };
    service_tier: string;
    store: boolean;
    temperature: number;
    text: {
        format: any;
    };
    tool_choice: string;
    tools: any[];
    top_p: number;
    truncation: string;
    usage: any;
    user: string | null;
    metadata: any;
};
type StreamChunk = {
    type: 'response.created';
    sequence_number: number;
    response: Response;
} | {
    type: 'response.in_progress';
    sequence_number: number;
    response: Response;
} | {
    type: 'response.output_item.added';
    sequence_number: number;
    output_index: number;
    item: {
        id: string;
        type: string;
        status: string;
        content: any[];
        role: string;
    };
} | {
    type: 'response.content_part.added';
    sequence_number: number;
    item_id: string;
    output_index: number;
    content_index: number;
    part: {
        type: string;
        annotations: any[];
        text: string;
    };
} | {
    type: 'response.output_text.delta';
    sequence_number: number;
    item_id: string;
    output_index: number;
    content_index: number;
    delta: string;
} | {
    type: 'response.output_text.done';
    sequence_number: number;
    item_id: string;
    output_index: 0;
    content_index: 0;
    text: string;
} | {
    type: 'response.content_part.done';
    sequence_number: number;
    item_id: string;
    output_index: number;
    content_index: number;
    part: {
        type: string;
        annotations: any[];
        text: string;
    };
} | {
    type: 'response.output_item.done';
    sequence_number: number;
    output_index: number;
    item: {
        id: string;
        type: string;
        status: string;
        content: any[];
        role: 'assistant';
    };
} | {
    type: 'response.completed';
    sequence_number: number;
    response: Response;
};
interface ResultState {
    responses: Array<Response>;
    _outputStaging?: Array<string>;
}
export declare const openAIStreamAPIstreamReducer: StreamReducer<StreamChunk, ResultState>;
export declare function summarizer(result: any): {
    usage: {
        [x: number]: any;
    };
} | {
    usage?: undefined;
};
export declare function makeOpenAIResponsesCreateProxy(originalCreate: any): any;
interface OpenAIAPI {
    chat: {
        completions: {
            create: any;
        };
    };
    images: {
        generate: any;
    };
    beta: {
        chat: {
            completions: {
                parse: any;
            };
        };
    };
    responses: {
        create: any;
    };
}
/**
 * Wraps the OpenAI API to enable function tracing for OpenAI calls.
 *
 * @example
 * const openai = wrapOpenAI(new OpenAI());
 * const result = await openai.chat.completions.create({
 *   model: 'gpt-3.5-turbo',
 *   messages: [{ role: 'user', content: 'Hello, world!' }]
 * });
 */
export declare function wrapOpenAI<T extends OpenAIAPI>(openai: T): T;
export declare function instrumentOpenAI(): void;
export {};
//# sourceMappingURL=openai.d.ts.map