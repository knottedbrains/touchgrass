"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Netrc = void 0;
const fs_1 = require("fs");
const os_1 = require("os");
const path_1 = require("path");
class Netrc {
    constructor(path = (0, path_1.join)((0, os_1.homedir)(), '.netrc')) {
        this.path = path;
        this.entries = new Map();
        this.load();
    }
    load() {
        try {
            const content = (0, fs_1.readFileSync)(this.path, 'utf8');
            let currentEntry = {};
            const lines = content.split('\n');
            for (const line of lines) {
                const [key, value] = line.trim().split(/\s+/);
                if (key === 'machine') {
                    if (currentEntry.machine && currentEntry.login) {
                        this.entries.set(currentEntry.machine, currentEntry);
                    }
                    currentEntry = { machine: value };
                }
                else if (key === 'login' || key === 'password') {
                    currentEntry[key] = value;
                }
            }
            if (currentEntry.machine && currentEntry.login) {
                this.entries.set(currentEntry.machine, currentEntry);
            }
        }
        catch (error) {
            console.error('Error parsing netrc file', error);
        }
    }
    save() {
        const content = Array.from(this.entries.entries())
            .map(([machine, entry]) => {
            let str = `machine ${machine}\n`;
            if (entry.login)
                str += `  login ${entry.login}\n`;
            if (entry.password)
                str += `  password ${entry.password}\n`;
            return str;
        })
            .join('\n');
        (0, fs_1.writeFileSync)(this.path, content, { mode: 0o600 });
    }
    getEntry(machine) {
        return this.entries.get(machine);
    }
    setEntry({ machine, ...entryProps }) {
        var _a;
        if (!machine) {
            throw new Error('Machine is required');
        }
        const existing = (_a = this.entries.get(machine)) !== null && _a !== void 0 ? _a : { machine };
        const updated = { ...existing, ...entryProps, machine };
        this.entries.set(machine, updated);
    }
    getLastEntry() {
        const entries = Array.from(this.entries.values());
        return entries[entries.length - 1];
    }
}
exports.Netrc = Netrc;
//# sourceMappingURL=netrc.js.map