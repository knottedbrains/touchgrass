"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConcurrencyLimiter = void 0;
class ConcurrencyLimiter {
    constructor(limit) {
        this.limit = limit;
        this.activeCount = 0;
        this.queue = [];
    }
    get active() {
        return this.activeCount;
    }
    get pending() {
        return this.queue.length;
    }
    tryExecuteNext() {
        if (this.queue.length > 0 && this.activeCount < this.limit) {
            const nextTask = this.queue.shift();
            this.activeCount++;
            nextTask();
        }
    }
    limitFunction(asyncFn) {
        return async (...args) => {
            return new Promise((resolve, reject) => {
                const task = async () => {
                    try {
                        const result = await asyncFn(...args);
                        resolve(result);
                    }
                    catch (e) {
                        reject(e);
                    }
                    finally {
                        this.activeCount--;
                        this.tryExecuteNext();
                    }
                };
                if (this.activeCount < this.limit) {
                    this.activeCount++;
                    task();
                }
                else {
                    this.queue.push(task);
                }
            });
        };
    }
}
exports.ConcurrencyLimiter = ConcurrencyLimiter;
//# sourceMappingURL=concurrencyLimit.js.map