'use strict';
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.reset = void 0;
const path_1 = __importDefault(require("path"));
const semifies_1 = __importDefault(require("semifies"));
const instrumentations_1 = __importDefault(require("../integrations/instrumentations"));
const npmModuleUtils_1 = require("./npmModuleUtils");
const parse = require('module-details-from-path');
let reset = () => { };
exports.reset = reset;
let patching = Object.create(null);
const cachedModules = new Map();
const passThroughModules = new Set();
if (typeof module !== 'undefined' && module.exports) {
    // CommonJS environment
    const Module = require('module');
    const originalRequire = Module.prototype.require;
    function patchedRequire(request) {
        let filename;
        try {
            filename = Module._resolveFilename(request, this);
        }
        catch (resolveErr) {
            return originalRequire.apply(this, arguments);
        }
        const isCoreModule = filename.indexOf(path_1.default.sep) === -1 || filename.startsWith('node:');
        if (isCoreModule) {
            // There is no business need to patch a core module yet, directly return with the original require
            return originalRequire.apply(this, arguments);
        }
        const parsed = parse(filename);
        if (parsed === undefined) {
            return originalRequire.apply(this, arguments);
        }
        const { name, basedir, path: subPath } = parsed;
        const instrumentationLookupKey = `${name}@${subPath}`;
        // if no hook is registered for this module, use the original require
        if (!instrumentations_1.default.has(instrumentationLookupKey)) {
            return originalRequire.apply(this, arguments);
        }
        // if the module was already seen and no applicable hook was found, pass through the module
        if (passThroughModules.has(filename)) {
            return originalRequire.apply(this, arguments);
        }
        if (!cachedModules.has(filename)) {
            const isPatching = patching[filename];
            if (isPatching) {
                // If it's already patched, just return it as-is. It might be a circular call-chain coming from the call on line 72.
                return originalRequire.apply(this, arguments);
            }
            else {
                patching[filename] = true;
            }
            const originalExports = originalRequire.apply(this, arguments);
            let instrumentation;
            let packageJson;
            try {
                packageJson = (0, npmModuleUtils_1.requirePackageJson)(basedir, module.paths);
            }
            catch (e) {
                console.log('Cannot find package.json for', name, basedir);
                return originalExports;
            }
            const version = packageJson.version;
            for (const instrumentationCandiate of instrumentations_1.default.get(instrumentationLookupKey) || []) {
                // check if the version is compatible with the current version of the module
                if ((0, semifies_1.default)(version, instrumentationCandiate.version)) {
                    instrumentation = instrumentationCandiate;
                    break;
                }
            }
            if (!instrumentation) {
                // Non of the instrumentations matched (maybe the version is not compatible), so we pass through the module
                passThroughModules.add(filename);
                return originalExports;
            }
            const hook = instrumentation.hook;
            const cacheEntry = {
                originalExports,
                patchedExports: hook(originalExports, name, basedir),
            };
            cachedModules.set(filename, cacheEntry);
            delete patching[filename];
        }
        return cachedModules.get(filename).patchedExports;
    }
    exports.reset = () => {
        Module.prototype.require = originalRequire;
    };
    Module.prototype.require = patchedRequire;
}
else {
    // ESM mode, do nothing
}
//# sourceMappingURL=commonJSLoader.js.map