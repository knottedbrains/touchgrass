import { CallSchema, CallsFilter, Api as TraceServerApi } from './generated/traceServerApi';
import { Op, OpRef, ParameterNamesOption } from './opType';
import { Settings } from './settings';
import { WandbServerApi } from './wandb/wandbServerApi';
import { ObjectRef } from './weaveObject';
import { Call, InternalCall } from './call';
export type CallStackEntry = {
    callId: string;
    traceId: string;
    childSummary: Record<string, any>;
};
declare class CallStack {
    private stack;
    constructor(stack?: CallStackEntry[]);
    peek(): CallStackEntry | null;
    pushNewCall(): {
        currentCall: CallStackEntry;
        parentCall?: CallStackEntry;
        newStack: CallStack;
    };
}
export declare class WeaveClient {
    traceServerApi: TraceServerApi<any>;
    private wandbServerApi;
    projectId: string;
    settings: Settings;
    private stackContext;
    private callQueue;
    private batchProcessTimeout;
    private isBatchProcessing;
    private batchProcessingPromises;
    private readonly BATCH_INTERVAL;
    private errorCount;
    private readonly MAX_ERRORS;
    constructor(traceServerApi: TraceServerApi<any>, wandbServerApi: WandbServerApi, projectId: string, settings?: Settings);
    private scheduleBatchProcessing;
    waitForBatchProcessing(): Promise<void>;
    private processBatch;
    publish(obj: any, objId?: string): Promise<ObjectRef>;
    getCall(callId: string, includeCosts?: boolean): Promise<Call>;
    getCalls(filter?: CallsFilter, includeCosts?: boolean, limit?: number): Promise<Call[]>;
    getCallsIterator(filter?: CallsFilter, includeCosts?: boolean, limit?: number): AsyncIterableIterator<CallSchema>;
    get(ref: ObjectRef): Promise<any>;
    private saveArbitrary;
    private saveObject;
    private saveTable;
    /**
     * Recursively save a Weave value, attaching __savedRef Promises to
     * nested value that gets its own ref.
     *
     * This function must be synchronous, so that code that does ref-tracking
     * (currently only Dataset/DatasetRow in the js client) has refs
     * available immediately.
     */
    private saveWeaveValues;
    private serializedFileBlob;
    private serializedImage;
    private serializedAudio;
    /**
     * Get the serialized value of a Weave value, by recursively
     * resolving any __savedRef promises to their uri().
     *
     * This function is asynchronous, and must be called after saveWeaveValues
     * has been called on the value.
     */
    private serializedVal;
    private saveCallStart;
    private saveCallEnd;
    getCallStack(): CallStack;
    pushNewCall(): {
        currentCall: CallStackEntry;
        parentCall?: CallStackEntry;
        newStack: CallStack;
    };
    runWithCallStack<T>(callStack: CallStack, fn: () => T): T;
    private paramsToCallInputs;
    saveOp(op: Op<(...args: any[]) => any>, objId?: string): Promise<any>;
    createCall(internalCall: InternalCall, opRef: OpRef | Op<any>, params: any[], parameterNames: ParameterNamesOption, thisArg: any, currentCall: CallStackEntry, parentCall: CallStackEntry | undefined, startTime: Date, displayName?: string): Promise<void>;
    finishCall(call: InternalCall, result: any, currentCall: CallStackEntry, parentCall: CallStackEntry | undefined, summarize: undefined | ((result: any) => Record<string, any>), endTime: Date, startCallPromise: Promise<void>): Promise<void>;
    finishCallWithException(call: InternalCall, error: any, currentCall: CallStackEntry, parentCall: CallStackEntry | undefined, endTime: Date, startCallPromise: Promise<void>): Promise<void>;
    updateCall(callId: string, displayName: string): Promise<void>;
}
export {};
//# sourceMappingURL=weaveClient.d.ts.map